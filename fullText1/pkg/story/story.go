package story

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/zicongmei/ai-story/fullText1/pkg/utils"
)

// getChapterCountFromGeminiForStory sends the abstract to Gemini to get a pure chapter count for story generation.
func getChapterCountFromGeminiForStory(apiKey, modelName, thinkingLevel, abstract string) (int, int, int, float64, error) { // Updated signature
	prompt := fmt.Sprintf(`Given the following complete story abstract (plan), please return ONLY the total number of chapters planned within it.
Do not include any other text, explanation, or formatting. Just the pure number.
If no chapters are explicitly outlined, return 0.

--- Story Abstract ---
%s
--- End Story Abstract ---
`, abstract)

	// Note: We pass nil for history here as this is a standalone request
	countStr, _, inputTokens, outputTokens, cost, err := utils.CallGeminiAPI(context.Background(), apiKey, modelName, prompt, thinkingLevel, nil) // Updated call
	if err != nil {
		return 0, 0, 0, 0, fmt.Errorf("error calling Gemini to get chapter count for story: %w", err)
	}

	// Clean up the response to ensure it's a pure number
	countStr = strings.TrimSpace(countStr)
	// Take only the first line in case Gemini adds extra text after the number
	countStr = strings.Split(countStr, "\n")[0]

	count, err := strconv.Atoi(countStr)
	if err != nil {
		return 0, inputTokens, outputTokens, cost, fmt.Errorf("could not parse chapter count '%s' from Gemini response for story: %w", countStr, err)
	}

	return count, inputTokens, outputTokens, cost, nil
}

// getWrittenChapterCountFromGemini sends the existing story content to Gemini to identify the last fully written chapter.
func getWrittenChapterCountFromGemini(apiKey, modelName, thinkingLevel, existingStoryContent string) (int, int, int, float64, error) { // Updated signature
	prompt := fmt.Sprintf(`Given the following story text, identify the number of the last *fully written* chapter.
Look for chapter headers like '## Chapter X' (where X is the chapter number).
Return ONLY the number.
If no fully written chapters are found, or if the last detected chapter appears incomplete (e.g., ends abruptly or contains error messages), return 0.
Do not include any other text, explanation, or formatting. Just the pure integer number.

--- Existing Story Content ---
%s
--- End Existing Story Content ---
`, existingStoryContent)

	// Note: We pass nil for history here as this is a standalone request
	countStr, _, inputTokens, outputTokens, cost, err := utils.CallGeminiAPI(context.Background(), apiKey, modelName, prompt, thinkingLevel, nil) // Updated call
	if err != nil {
		return 0, 0, 0, 0, fmt.Errorf("error calling Gemini to get written chapter count: %w", err)
	}

	countStr = strings.TrimSpace(countStr)
	countStr = strings.Split(countStr, "\n")[0] // Take only the first line

	count, err := strconv.Atoi(countStr)
	if err != nil {
		return 0, inputTokens, outputTokens, cost, fmt.Errorf("could not parse written chapter count '%s' from Gemini response: %w", countStr, err)
	}

	return count, inputTokens, outputTokens, cost, nil
}

// Execute is the main entry point for the 'story' subcommand.
func Execute(args []string) error {
	cmd := flag.NewFlagSet("story", flag.ContinueOnError)
	cmd.Usage = func() {
		fmt.Fprintf(cmd.Output(), "Usage of %s story:\n", os.Args[0])
		cmd.PrintDefaults()
	}

	configPath := cmd.String("config", "", "Path to Gemini configuration JSON file (optional). If not provided, API key is taken from GEMINI_API_KEY env var and model defaults to 'gemini-pro'.")
	abstractFilePath := cmd.String("abstract-file", "", "Path to the abstract file (text or json) generated by the 'abstract' command.")
	wordsPerChapter := cmd.Int("words-per-chapter", 5000, "Desired average number of words per chapter (actual count may vary by +/- 20%).")
	outputPath := cmd.String("output", "", "Path to save the generated full story file (default: fulltext-yyyy-mm-dd-hh-mm-ss.txt based on abstract filename).")

	if err := cmd.Parse(args); err != nil {
		return fmt.Errorf("failed to parse story subcommand flags: %w", err)
	}

	if *abstractFilePath == "" {
		return fmt.Errorf("--abstract-file is required for story generation")
	}
	if *wordsPerChapter <= 0 {
		return fmt.Errorf("--words-per-chapter must be a positive number")
	}

	// --- Configure logging to a file based on abstract name ---
	// Preserve original log output and flags
	originalLogOutput := log.Writer()
	originalLogFlags := log.Flags()
	defer func() {
		log.SetOutput(originalLogOutput) // Restore original log output when Execute exits
		log.SetFlags(originalLogFlags)   // Restore original log flags
	}()

	abstractFileName := filepath.Base(*abstractFilePath)
	logFileName := ""
	if strings.HasPrefix(strings.ToLower(abstractFileName), "abstract-") && (strings.HasSuffix(strings.ToLower(abstractFileName), ".txt") || strings.HasSuffix(strings.ToLower(abstractFileName), ".json")) {
		// Example: abstract-2025-11-17-20-59-12.txt/json -> log-2025-11-17-20-59-12.log
		logFileName = strings.Replace(abstractFileName, "abstract-", "log-", 1)
		logFileName = strings.Replace(logFileName, ".txt", ".log", 1)
		logFileName = strings.Replace(logFileName, ".json", ".log", 1)
	} else {
		// Fallback for abstract files not matching the standard pattern
		timestamp := time.Now().Format("2006-01-02-15-04-05")
		logFileName = fmt.Sprintf("story-log-%s.log", timestamp)
	}

	logFile, err := os.OpenFile(logFileName, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		log.Printf("Warning: Failed to open log file '%s': %v. Logging will continue to stderr.", logFileName, err)
		// If log file creation fails, don't change log output, just use stderr.
	} else {
		// Use MultiWriter to write to both the file and stderr
		mw := io.MultiWriter(os.Stderr, logFile)
		log.SetOutput(mw)
		log.Printf("Logging to file: %s", logFileName)
		defer logFile.Close() // Ensure the log file is closed
	}
	// --- End logging configuration ---

	// Load Gemini config using the utility function
	apiKey, modelName, thinkingLevel, err := utils.LoadGeminiConfigWithFallback(*configPath) // Updated to receive thinkingLevel
	if err != nil {
		return err // utils.LoadGeminiConfigWithFallback already logs detailed errors.
	}

	// Read abstract file
	abstractContentBytes, err := os.ReadFile(*abstractFilePath)
	if err != nil {
		return fmt.Errorf("failed to read abstract file '%s': %w", *abstractFilePath, err)
	}
	abstractContent := string(abstractContentBytes)

	// Check if abstract is JSON and parse it
	if strings.HasSuffix(strings.ToLower(*abstractFilePath), ".json") {
		var abstractData struct {
			Abstract string `json:"abstract"`
		}
		if err := json.Unmarshal(abstractContentBytes, &abstractData); err != nil {
			return fmt.Errorf("failed to parse JSON abstract file: %w", err)
		}
		abstractContent = abstractData.Abstract
		log.Printf("Successfully parsed abstract content from JSON file.")
	}

	// Get total chapter count from Gemini based on the abstract plan
	log.Printf("Sending abstract to Gemini to get the total number of chapters planned...")
	totalChapters, inputTokensCountPlan, outputTokensCountPlan, costCountPlan, err := getChapterCountFromGeminiForStory(apiKey, modelName, thinkingLevel, abstractContent) // Updated call
	if err != nil {
		return fmt.Errorf("failed to get total chapter count from Gemini for story generation: %w", err)
	}
	log.Printf("Chapter plan determination complete. Input tokens: %d, Output tokens: %d, Cost: $%.6f", inputTokensCountPlan, outputTokensCountPlan, costCountPlan)

	if totalChapters == 0 {
		return fmt.Errorf("Gemini returned 0 planned chapters for the abstract. Cannot proceed with story generation.")
	}
	fmt.Printf("Total chapters identified by Gemini for story generation: %d\n", totalChapters)
	log.Printf("Total chapters identified by Gemini for story generation: %d", totalChapters)

	// Determine output path
	finalOutputPath := *outputPath
	if finalOutputPath == "" {
		re := strings.NewReplacer("abstract-", "fulltext-")
		baseName := filepath.Base(*abstractFilePath)
		if strings.HasPrefix(strings.ToLower(baseName), "abstract-") {
			finalOutputPath = re.Replace(baseName)
			finalOutputPath = strings.Replace(finalOutputPath, ".json", ".txt", 1) // Ensure text extension
		} else {
			timestamp := time.Now().Format("2006-01-02-15-04-05")
			finalOutputPath = fmt.Sprintf("fulltext-%s.txt", timestamp)
		}
	}

	// Initialize variables for resuming logic
	var chaptersAlreadyWritten int = 0
	var existingStoryContent string = ""
	var fileMode int // Will be set to os.O_CREATE|os.O_WRONLY or os.O_APPEND|os.O_WRONLY
	var firstNewChapter int = 1
	var accumulatedInputTokens = inputTokensCountPlan
	var accumulatedOutputTokens = outputTokensCountPlan
	var accumulatedCost = costCountPlan

	// Check if output file already exists to determine resume point
	if _, err := os.Stat(finalOutputPath); err == nil {
		log.Printf("Output file '%s' already exists. Checking for existing chapters to resume...", finalOutputPath)
		contentBytes, readErr := os.ReadFile(finalOutputPath)
		if readErr != nil {
			log.Printf("Warning: Failed to read existing file '%s' to determine written chapters: %v. Starting from Chapter 1 (will overwrite if abstract/header is incomplete).", finalOutputPath, readErr)
			fileMode = os.O_CREATE | os.O_WRONLY
		} else {
			existingStoryContent = string(contentBytes)
			// Ask Gemini to count chapters in the existing content
			count, inputToks, outputToks, costToks, chapterCountErr := getWrittenChapterCountFromGemini(apiKey, modelName, thinkingLevel, existingStoryContent) // Updated call
			accumulatedInputTokens += inputToks
			accumulatedOutputTokens += outputToks
			accumulatedCost += costToks

			if chapterCountErr != nil {
				log.Printf("Warning: Failed to get written chapter count from Gemini for existing file: %v. Assuming 0 chapters written and starting from Chapter 1 (will overwrite if abstract/header is incomplete).", chapterCountErr)
				fileMode = os.O_CREATE | os.O_WRONLY
			} else {
				chaptersAlreadyWritten = count
				if chaptersAlreadyWritten > 0 {
					firstNewChapter = chaptersAlreadyWritten + 1
					fileMode = os.O_APPEND | os.O_WRONLY // Open in append mode
					log.Printf("Detected %d chapters already written in '%s'. Resuming generation from Chapter %d.", chaptersAlreadyWritten, finalOutputPath, firstNewChapter)
				} else {
					log.Printf("No complete chapters detected in existing file '%s'. Starting from Chapter 1 (will overwrite if abstract/header is incomplete).", finalOutputPath)
					fileMode = os.O_CREATE | os.O_WRONLY
				}
			}
		}
	} else {
		log.Printf("Output file '%s' does not exist. Starting new story generation from Chapter 1.", finalOutputPath)
		fileMode = os.O_CREATE | os.O_WRONLY
	}

	// Open the output file for writing based on determined mode
	f, err := os.OpenFile(finalOutputPath, fileMode, 0644)
	if err != nil {
		return fmt.Errorf("error opening/creating output file '%s': %w", finalOutputPath, err)
	}
	defer f.Close()

	// If starting fresh (new file or detected 0 chapters), write initial header and abstract
	if chaptersAlreadyWritten == 0 {
		fmt.Fprintf(f, "--- Full Story: %s ---\n\n", time.Now().Format("2006-01-02 15:04:05"))
		fmt.Fprintf(f, "Story Plan Abstract:\n%s\n\n", abstractContent)
		fmt.Fprintf(f, "----------------------------------------\n\n")
	}

	// previousChapters will accumulate generated chapters to be sent as context.
	// If resuming, it starts with the existing content up to the point of resume.
	previousChapters := existingStoryContent

	// Track the history turn from the previous chapter generation for use in the next
	var currentHistory *utils.HistoryTurn = nil

	// Generate story chapter by chapter, starting from 'firstNewChapter'
	log.Printf("Starting full story generation from Chapter %d to Chapter %d, aiming for %d words per chapter...", firstNewChapter, totalChapters, *wordsPerChapter)

	const maxChapterRetries = 3 // Number of retries for chapter generation
	for i := firstNewChapter - 1; i < totalChapters; i++ {
		chapterNum := i + 1

		log.Printf("Generating Chapter %d (out of %d)", chapterNum, totalChapters)

		prompt := fmt.Sprintf(`Given the following complete story abstract (plan) and the chapters already written, please write Chapter %d of the story.
Generate a short title for the charpter.
The chapter should be approximately %d words. Focus on progressing the narrative as outlined in the abstract for this specific chapter.

--- Full Story Abstract (Plan) ---
%s
--- End Full Story Abstract (Plan) ---

--- Previously Written Chapters (including abstract and previous chapters) ---
%s
--- End Previously Written Chapters ---

Write Chapter %d now, ensuring it flows logically from previous chapters and adheres to the overall story plan.
`,
			chapterNum,
			*wordsPerChapter,
			abstractContent,  // Send the *entire* abstract content
			previousChapters, // This will contain existing content (if resuming) + newly generated chapters
			chapterNum,
		)

		var chapterText string
		var chapterSignature []byte
		var chapterInputTokens, chapterOutputTokens int
		var chapterCost float64
		var chapterGenerationErr error

		// Retry logic for CallGeminiAPI for chapter generation
		for attempt := 0; attempt <= maxChapterRetries; attempt++ {
			if attempt > 0 {
				log.Printf("Retrying Chapter %d (attempt %d/%d) after previous failure: %v", chapterNum, attempt, maxChapterRetries, chapterGenerationErr)
				time.Sleep(2 * time.Second) // Small delay before retrying
			}

			// Updated call to include thinkingLevel and history
			chapterText, chapterSignature, chapterInputTokens, chapterOutputTokens, chapterCost, chapterGenerationErr = utils.CallGeminiAPI(context.Background(), apiKey, modelName, prompt, thinkingLevel, currentHistory)
			if chapterGenerationErr == nil {
				// Success, break out of retry loop
				break
			}
		}

		if chapterGenerationErr != nil {
			log.Fatalf("Critical Error: Failed to generate Chapter %d after %d attempts: %v. Marking chapter with error message and proceeding.", chapterNum, maxChapterRetries+1, chapterGenerationErr)

		}

		// Accumulate token counts and cost
		accumulatedInputTokens += chapterInputTokens
		accumulatedOutputTokens += chapterOutputTokens
		accumulatedCost += chapterCost
		log.Printf("Chapter %d tokens: Input %d, Output %d, Cost: $%.6f. Accumulated tokens: Input %d, Output %d, Accumulated Cost: $%.6f",
			chapterNum, chapterInputTokens, chapterOutputTokens, chapterCost, accumulatedInputTokens, accumulatedOutputTokens, accumulatedCost)

		// Write the generated chapter directly to the file
		chapterHeader := fmt.Sprintf("## Chapter %d\n\n", chapterNum)
		chapterContentToWrite := strings.TrimSpace(chapterText) + "\n\n"

		if _, err := f.WriteString(chapterHeader); err != nil {
			log.Printf("Error writing chapter header for Chapter %d to file: %v", chapterNum, err)
		}
		if _, err := f.WriteString(chapterContentToWrite); err != nil {
			log.Printf("Error writing Chapter %d content to file: %v", chapterNum, err)
		}
		log.Printf("Chapter %d generated and written to file: %s", chapterNum, finalOutputPath)

		// Append the newly generated chapter to previousChapters for the *next* iteration's context
		previousChapters += chapterHeader + chapterContentToWrite

		// Update the history for the next iteration to maintain the thought signature chain
		currentHistory = &utils.HistoryTurn{
			UserPrompt:       prompt,
			ModelResponse:    chapterText,
			ThoughtSignature: chapterSignature,
		}

		// Add a small delay to avoid hitting rate limits if generating many chapters quickly
		time.Sleep(1 * time.Second)
	}

	fmt.Printf("Full story successfully generated and saved to: %s\n", finalOutputPath)
	log.Printf("Full story saved to: %s. Total accumulated tokens: Input %d, Output %d. Total accumulated cost: $%.6f", finalOutputPath, accumulatedInputTokens, accumulatedOutputTokens, accumulatedCost)
	fmt.Printf("Total accumulated cost for full story generation process: $%.6f\n", accumulatedCost)

	return nil
}