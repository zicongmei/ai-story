package story

import (
	"context"
	"flag"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/zicongmei/ai-story/fullText1/pkg/utils"
)

// getChapterCountFromGeminiForStory sends the abstract to Gemini to get a pure chapter count for story generation.
func getChapterCountFromGeminiForStory(apiKey, modelName, abstract string) (int, int, int, error) { // Updated signature
	prompt := fmt.Sprintf(`Given the following complete story abstract (plan), please return ONLY the total number of chapters planned within it.
Do not include any other text, explanation, or formatting. Just the pure number.
If no chapters are explicitly outlined, return 0.

--- Story Abstract ---
%s
--- End Story Abstract ---
`, abstract)

	countStr, inputTokens, outputTokens, err := utils.CallGeminiAPI(context.Background(), apiKey, modelName, prompt) // Updated call
	if err != nil {
		return 0, 0, 0, fmt.Errorf("error calling Gemini to get chapter count for story: %w", err)
	}

	// Clean up the response to ensure it's a pure number
	countStr = strings.TrimSpace(countStr)
	// Take only the first line in case Gemini adds extra text after the number
	countStr = strings.Split(countStr, "\n")[0]

	count, err := strconv.Atoi(countStr)
	if err != nil {
		return 0, inputTokens, outputTokens, fmt.Errorf("could not parse chapter count '%s' from Gemini response for story: %w", countStr, err)
	}

	return count, inputTokens, outputTokens, nil
}

// Execute is the main entry point for the 'story' subcommand.
func Execute(args []string) error {
	cmd := flag.NewFlagSet("story", flag.ContinueOnError)
	cmd.Usage = func() {
		fmt.Fprintf(cmd.Output(), "Usage of %s story:\n", os.Args[0])
		cmd.PrintDefaults()
	}

	configPath := cmd.String("config", "", "Path to Gemini configuration JSON file (optional). If not provided, API key is taken from GEMINI_API_KEY env var and model defaults to 'gemini-pro'.")
	abstractFilePath := cmd.String("abstract-file", "", "Path to the abstract text file generated by the 'abstract' command.")
	wordsPerChapter := cmd.Int("words-per-chapter", 5000, "Desired average number of words per chapter (actual count may vary by +/- 20%).")
	outputPath := cmd.String("output", "", "Path to save the generated full story file (default: fulltext-yyyy-mm-dd-hh-mm-ss.txt based on abstract filename).")

	if err := cmd.Parse(args); err != nil {
		return fmt.Errorf("failed to parse story subcommand flags: %w", err)
	}

	if *abstractFilePath == "" {
		return fmt.Errorf("--abstract-file is required for story generation")
	}
	if *wordsPerChapter <= 0 {
		return fmt.Errorf("--words-per-chapter must be a positive number")
	}

	// Load Gemini config using the utility function
	apiKey, modelName, err := utils.LoadGeminiConfigWithFallback(*configPath)
	if err != nil {
		return err // utils.LoadGeminiConfigWithFallback already logs detailed errors.
	}

	// Read abstract file
	abstractContentBytes, err := os.ReadFile(*abstractFilePath)
	if err != nil {
		return fmt.Errorf("failed to read abstract file '%s': %w", *abstractFilePath, err)
	}
	abstractContent := string(abstractContentBytes)

	// New Step: Get total chapter count from Gemini based on the abstract
	log.Printf("Sending abstract to Gemini to get the total number of chapters...")
	totalChapters, inputTokensCount, outputTokensCount, err := getChapterCountFromGeminiForStory(apiKey, modelName, abstractContent) // Updated call
	if err != nil {
		return fmt.Errorf("failed to get total chapter count from Gemini for story generation: %w", err)
	}
	log.Printf("Chapter count determination complete. Input tokens: %d, Output tokens: %d", inputTokensCount, outputTokensCount)


	if totalChapters == 0 {
		return fmt.Errorf("Gemini returned 0 chapters for the abstract. Cannot proceed with story generation.")
	}
	fmt.Printf("Total chapters identified by Gemini for story generation: %d\n", totalChapters)
	log.Printf("Total chapters identified by Gemini for story generation: %d", totalChapters)

	// Determine output path
	finalOutputPath := *outputPath
	if finalOutputPath == "" {
		// Replace "abstract-" with "fulltext-" and keep the timestamp
		// This regex ensures we only modify filenames following the 'abstract-YYYY-MM-DD-HH-MM-SS.txt' pattern
		// if it doesn't match, we fall back to a new timestamped name.
		re := strings.NewReplacer("abstract-", "fulltext-")
		if strings.HasPrefix(strings.ToLower(*abstractFilePath), "abstract-") && strings.HasSuffix(strings.ToLower(*abstractFilePath), ".txt") {
			finalOutputPath = re.Replace(*abstractFilePath)
		} else {
			// Fallback if the abstract file name doesn't match the expected pattern
			timestamp := time.Now().Format("2006-01-02-15-04-05")
			finalOutputPath = fmt.Sprintf("fulltext-%s.txt", timestamp)
		}
	}

	// Open the output file for writing, creating it if it doesn't exist, and appending to it
	f, err := os.OpenFile(finalOutputPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return fmt.Errorf("error opening/creating output file '%s': %w", finalOutputPath, err)
	}
	defer f.Close() // Ensure the file is closed when the function exits

	// Write initial header and abstract to the file
	fmt.Fprintf(f, "--- Full Story: %s ---\n\n", time.Now().Format("2006-01-02 15:04:05"))
	fmt.Fprintf(f, "Story Plan Abstract:\n%s\n\n", abstractContent)
	fmt.Fprintf(f, "----------------------------------------\n\n")

	// Initialize accumulated token counts
	accumulatedInputTokens := inputTokensCount // Start with the tokens from counting chapters
	accumulatedOutputTokens := outputTokensCount


	// Generate story chapter by chapter
	log.Printf("Starting full story generation for %d chapters, aiming for %d words per chapter...", totalChapters, *wordsPerChapter)

	previousChapters := "" // Accumulate generated chapters for context
	for i := 0; i < totalChapters; i++ {
		chapterNum := i + 1

		log.Printf("Generating Chapter %d", chapterNum)

		prompt := fmt.Sprintf(`Given the following complete story abstract (plan) and the chapters already written, please write Chapter %d of the story.
The chapter should be approximately %d words. Focus on progressing the narrative as outlined in the abstract for this specific chapter.

--- Full Story Abstract (Plan) ---
%s
--- End Full Story Abstract (Plan) ---

--- Previously Written Chapters ---
%s
--- End Previously Written Chapters ---

Write Chapter %d now, ensuring it flows logically from previous chapters and adheres to the overall story plan.
`,
			chapterNum,
			*wordsPerChapter,
			abstractContent, // Send the *entire* abstract content
			previousChapters,
			chapterNum,
		)

		chapterText, chapterInputTokens, chapterOutputTokens, err := utils.CallGeminiAPI(context.Background(), apiKey, modelName, prompt) // Updated call
		if err != nil {
			log.Printf("Warning: Failed to generate Chapter %d: %v. Attempting to continue with next chapter.", chapterNum, err)
			chapterText = fmt.Sprintf("\n\n[ERROR: Failed to generate Chapter %d: %v]\n\n", chapterNum, err)
			chapterInputTokens = 0 // On error, we might not get valid token counts from the failed call itself
			chapterOutputTokens = 0
		}

		// Accumulate token counts
		accumulatedInputTokens += chapterInputTokens
		accumulatedOutputTokens += chapterOutputTokens
		log.Printf("Chapter %d tokens: Input %d, Output %d. Accumulated tokens: Input %d, Output %d",
			chapterNum, chapterInputTokens, chapterOutputTokens, accumulatedInputTokens, accumulatedOutputTokens)


		// Write the generated chapter directly to the file
		chapterHeader := fmt.Sprintf("## Chapter %d\n\n", chapterNum)
		chapterContentToWrite := strings.TrimSpace(chapterText) + "\n\n"

		if _, err := f.WriteString(chapterHeader); err != nil {
			log.Printf("Error writing chapter header for Chapter %d to file: %v", chapterNum, err)
		}
		if _, err := f.WriteString(chapterContentToWrite); err != nil {
			log.Printf("Error writing Chapter %d content to file: %v", chapterNum, err)
		}
		log.Printf("Chapter %d generated and written to file: %s", chapterNum, finalOutputPath)

		previousChapters += fmt.Sprintf("## Chapter %d\n\n%s\n\n", chapterNum, strings.TrimSpace(chapterText))
		// Add a small delay to avoid hitting rate limits if generating many chapters quickly
		time.Sleep(1 * time.Second)
	}

	fmt.Printf("Full story successfully generated and saved to: %s\n", finalOutputPath)
	log.Printf("Full story saved to: %s. Total accumulated tokens: Input %d, Output %d", finalOutputPath, accumulatedInputTokens, accumulatedOutputTokens)

	return nil
}