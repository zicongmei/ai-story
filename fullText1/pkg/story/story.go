package story

import (
	"context"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/zicongmei/ai-story/fullText1/pkg/abstract/file"
	"github.com/zicongmei/ai-story/fullText1/pkg/aiEndpoint"
)

// GetChapterCountForStoryInput holds input parameters for getChapterCountFromGeminiForStory.
type GetChapterCountForStoryInput struct {
	APIKey        string
	ModelName     string
	ThinkingLevel string
	Abstract      string
}

// getChapterCountFromGeminiForStory sends the abstract to Gemini to get a pure chapter count for story generation.
func getChapterCountFromGeminiForStory(input GetChapterCountForStoryInput) aiEndpoint.ChapterCountResult {
	var result aiEndpoint.ChapterCountResult

	prompt := fmt.Sprintf(`Given the following complete story abstract (plan), please return ONLY the total number of chapters planned within it.
Do not include any other text, explanation, or formatting. Just the pure number.
If no chapters are explicitly outlined, return 0.

--- Story Abstract ---
%s
--- End Story Abstract ---
`, input.Abstract)

	apiInput := aiEndpoint.CallGeminiAPIInput{
		Ctx:           context.Background(),
		APIKey:        input.APIKey,
		ModelName:     input.ModelName,
		Prompt:        prompt,
		ThinkingLevel: input.ThinkingLevel,
		PreviousTurn:  nil,
	}
	apiResponse := aiEndpoint.CallGeminiAPI(apiInput)

	if apiResponse.Err != nil {
		result.Err = fmt.Errorf("error calling Gemini to get chapter count for story: %w", apiResponse.Err)
		return result
	}

	countStr := strings.TrimSpace(apiResponse.GeneratedText)
	countStr = strings.Split(countStr, "\n")[0]

	count, err := strconv.Atoi(countStr)
	if err != nil {
		result.InputTokens = apiResponse.InputTokens
		result.OutputTokens = apiResponse.OutputTokens
		result.Cost = apiResponse.Cost
		result.Err = fmt.Errorf("could not parse chapter count '%s' from Gemini response for story: %w", countStr, err)
		return result
	}

	result.Count = count
	result.InputTokens = apiResponse.InputTokens
	result.OutputTokens = apiResponse.OutputTokens
	result.Cost = apiResponse.Cost
	return result
}

// FullStoryConfig holds all configuration needed for story generation.
type FullStoryConfig struct {
	ConfigPath       string
	AbstractFilePath string
	WordsPerChapter  int
	OutputPath       string
	APIKey           string
	ModelName        string
	ThinkingLevel    string
	AbstractContent  string
}

// StoryProgressState holds the current state of the story generation,
// including accumulated tokens and the generated content for context.
type StoryProgressState struct {
	AccumulatedInputTokens  int
	AccumulatedOutputTokens int
	AccumulatedCost         float64
	PreviousChapters        string // Content of all chapters written so far, for context
	LastThoughtSignature    []byte // Last AI thought signature for continuity
	ChaptersAlreadyWritten  int
	FirstNewChapter         int
}

// parseAndValidateFlags parses command-line flags and performs initial validation.
func parseAndValidateFlags(args []string) (FullStoryConfig, error) {
	var cfg FullStoryConfig
	cmd := flag.NewFlagSet("story", flag.ContinueOnError)
	cmd.Usage = func() {
		fmt.Fprintf(cmd.Output(), "Usage of %s story:\n", os.Args[0])
		cmd.PrintDefaults()
	}

	cmd.StringVar(&cfg.ConfigPath, "config", "", "Path to Gemini configuration JSON file (optional). If not provided, API key is taken from GEMINI_API_KEY env var and model defaults to 'gemini-pro'.")
	cmd.StringVar(&cfg.AbstractFilePath, "abstract", "", "Path to the abstract file (text, json, or yaml) generated by the 'abstract' command.")
	cmd.IntVar(&cfg.WordsPerChapter, "words-per-chapter", 5000, "Desired average number of words per chapter (actual count may vary by +/- 20%).")
	cmd.StringVar(&cfg.OutputPath, "output", "", "Path to save the generated full story file (default: fulltext-yyyy-mm-dd-hh-mm-ss.txt based on abstract filename).")

	if err := cmd.Parse(args); err != nil {
		return cfg, fmt.Errorf("failed to parse story subcommand flags: %w", err)
	}

	if cfg.AbstractFilePath == "" {
		return cfg, fmt.Errorf("--abstract is required for story generation")
	}
	if cfg.WordsPerChapter <= 0 {
		return cfg, fmt.Errorf("--words-per-chapter must be a positive number")
	}
	return cfg, nil
}

// setupLogging configures file-based logging. It returns the opened log file, which the caller must close.
func setupLogging(abstractFilePath string) (*os.File, error) {
	originalLogOutput := log.Writer()
	originalLogFlags := log.Flags()

	abstractFileName := filepath.Base(abstractFilePath)
	logFileName := ""
	if strings.HasPrefix(strings.ToLower(abstractFileName), "abstract-") && (strings.HasSuffix(strings.ToLower(abstractFileName), ".txt") || strings.HasSuffix(strings.ToLower(abstractFileName), ".json") || strings.HasSuffix(strings.ToLower(abstractFileName), ".yaml") || strings.HasSuffix(strings.ToLower(abstractFileName), ".yml")) {
		logFileName = strings.Replace(abstractFileName, "abstract-", "log-", 1)
		logFileName = strings.Replace(logFileName, ".txt", ".log", 1)
		logFileName = strings.Replace(logFileName, ".json", ".log", 1)
		logFileName = strings.Replace(logFileName, ".yaml", ".log", 1)
		logFileName = strings.Replace(logFileName, ".yml", ".log", 1)
	} else {
		timestamp := time.Now().Format("2006-01-02-15-04-05")
		logFileName = fmt.Sprintf("story-log-%s.log", timestamp)
	}

	logFile, err := os.OpenFile(logFileName, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		log.Printf("Warning: Failed to open log file '%s': %v. Logging will continue to stderr.", logFileName, err)
		log.SetOutput(originalLogOutput) // Ensure logging goes to original output if file fails
		log.SetFlags(originalLogFlags)
		return nil, fmt.Errorf("failed to open log file: %w", err)
	}

	mw := io.MultiWriter(os.Stderr, logFile)
	log.SetOutput(mw)
	log.Printf("Logging to file: %s", logFileName)
	return logFile, nil
}

// loadGeminiAPIConfig loads Gemini API key, model name, and thinking level.
func loadGeminiAPIConfig(configPath string) (string, string, string, error) {
	geminiConfigDetails := aiEndpoint.LoadGeminiConfigWithFallback(configPath)
	if geminiConfigDetails.Err != nil {
		return "", "", "", geminiConfigDetails.Err
	}
	return geminiConfigDetails.APIKey, geminiConfigDetails.ModelName, geminiConfigDetails.ThinkingLevel, nil
}

// readAbstractAndDetermineTotalChapters reads the abstract file and gets the total planned chapters from Gemini.
func readAbstractAndDetermineTotalChapters(cfg FullStoryConfig) (string, int, int, int, float64, error) {
	abstractContent, _, err := file.ReadAbstractFile(cfg.AbstractFilePath) // thoughtSignature is currently unused
	if err != nil {
		return "", 0, 0, 0, 0, fmt.Errorf("failed to read and parse abstract file '%s': %w", cfg.AbstractFilePath, err)
	}

	log.Printf("Sending abstract to Gemini to get the total number of chapters planned...")
	getChapterCountForStoryInput := GetChapterCountForStoryInput{
		APIKey:        cfg.APIKey,
		ModelName:     cfg.ModelName,
		ThinkingLevel: cfg.ThinkingLevel,
		Abstract:      abstractContent,
	}
	chapterCountPlanResult := getChapterCountFromGeminiForStory(getChapterCountForStoryInput)
	if chapterCountPlanResult.Err != nil {
		return "", 0, 0, 0, 0, fmt.Errorf("failed to get total chapter count from Gemini for story generation: %w", chapterCountPlanResult.Err)
	}

	totalChapters := chapterCountPlanResult.Count
	if totalChapters == 0 {
		return "", 0, 0, 0, 0, fmt.Errorf("Gemini returned 0 planned chapters for the abstract. Cannot proceed with story generation.")
	}
	log.Printf("Chapter plan determination complete. Input tokens: %d, Output tokens: %d, Cost: $%.6f", chapterCountPlanResult.InputTokens, chapterCountPlanResult.OutputTokens, chapterCountPlanResult.Cost)
	fmt.Printf("Total chapters identified by Gemini for story generation: %d\n", totalChapters)
	log.Printf("Total chapters identified by Gemini for story generation: %d", totalChapters)

	return abstractContent, totalChapters, chapterCountPlanResult.InputTokens, chapterCountPlanResult.OutputTokens, chapterCountPlanResult.Cost, nil
}

// determineOutputFilePath calculates the final output file path.
func determineOutputFilePath(abstractFilePath, outputPathFlag string) string {
	if outputPathFlag != "" {
		return outputPathFlag
	}

	re := strings.NewReplacer("abstract-", "fulltext-")
	baseName := filepath.Base(abstractFilePath)
	if strings.HasPrefix(strings.ToLower(baseName), "abstract-") {
		finalOutputPath := re.Replace(baseName)
		finalOutputPath = strings.Replace(finalOutputPath, ".json", ".txt", 1)
		finalOutputPath = strings.Replace(finalOutputPath, ".yaml", ".txt", 1)
		finalOutputPath = strings.Replace(finalOutputPath, ".yml", ".txt", 1)
		return finalOutputPath
	}

	timestamp := time.Now().Format("2006-01-02-15-04-05")
	return fmt.Sprintf("fulltext-%s.txt", timestamp)
}

// determineStatusFilePath calculates the status file path based on the output file path.
func determineStatusFilePath(outputFilePath string) string {
	dir := filepath.Dir(outputFilePath)
	base := filepath.Base(outputFilePath)

	// Attempt to replace 'fulltext' with 'status'
	newBase := strings.Replace(base, "fulltext", "status", 1)
	if newBase == base {
		// If 'fulltext' wasn't present, just prefix
		newBase = "status-" + base
	}

	// Ensure extension is .yaml
	ext := filepath.Ext(newBase)
	if ext != "" {
		newBase = strings.TrimSuffix(newBase, ext) + ".yaml"
	} else {
		newBase = newBase + ".yaml"
	}

	return filepath.Join(dir, newBase)
}

// initializeStoryState loads existing progress from the status file or initializes a new state.
func initializeStoryState(statusFilePath string, abstractContent string) (StoryProgressState, error) {
	state := StoryProgressState{
		FirstNewChapter: 1,
	}

	if _, err := os.Stat(statusFilePath); err == nil {
		log.Printf("Found status file '%s'. Loading state...", statusFilePath)
		statusData, err := file.ReadStoryStatusFile(statusFilePath)
		if err != nil {
			return state, fmt.Errorf("failed to read status file: %w", err)
		}

		state.AccumulatedInputTokens = statusData.AccumulatedInputTokens
		state.AccumulatedOutputTokens = statusData.AccumulatedOutputTokens
		state.AccumulatedCost = statusData.AccumulatedCost
		state.PreviousChapters = statusData.PreviousChapters
		state.LastThoughtSignature = []byte(statusData.LastThoughtSignature)
		state.ChaptersAlreadyWritten = statusData.ChaptersWritten
		state.FirstNewChapter = state.ChaptersAlreadyWritten + 1

		log.Printf("Resuming from Chapter %d.", state.FirstNewChapter)
	} else {
		log.Printf("No status file found at '%s'. Starting new story.", statusFilePath)
		// Initialize header for new story
		header := fmt.Sprintf("--- Full Story: %s ---\n\nStory Plan Abstract:\n%s\n\n----------------------------------------\n\n", time.Now().Format("2006-01-02 15:04:05"), abstractContent)
		state.PreviousChapters = header
	}

	return state, nil
}

// saveStateToFiles saves the current state to the status YAML file and rewrites the full text output file.
func saveStateToFiles(state *StoryProgressState, statusFilePath, outputFilePath string) error {
	// Save Status File
	statusData := file.StoryStatus{
		PreviousChapters:        state.PreviousChapters,
		LastThoughtSignature:    string(state.LastThoughtSignature),
		AccumulatedInputTokens:  state.AccumulatedInputTokens,
		AccumulatedOutputTokens: state.AccumulatedOutputTokens,
		AccumulatedCost:         state.AccumulatedCost,
		ChaptersWritten:         state.ChaptersAlreadyWritten,
	}
	if err := file.WriteStoryStatusFile(statusFilePath, statusData); err != nil {
		return fmt.Errorf("failed to save status file: %w", err)
	}

	// Rewrite Full Text File
	if err := os.WriteFile(outputFilePath, []byte(state.PreviousChapters), 0644); err != nil {
		return fmt.Errorf("failed to write story output file: %w", err)
	}

	return nil
}

// generateStoryChapters loops through and generates each chapter, writing status and content to files.
func generateStoryChapters(
	cfg FullStoryConfig,
	totalChapters int,
	state *StoryProgressState,
	statusFilePath string,
	outputFilePath string,
) error {
	log.Printf("Starting full story generation from Chapter %d to Chapter %d, aiming for %d words per chapter...",
		state.FirstNewChapter, totalChapters, cfg.WordsPerChapter)

	const maxChapterRetries = 3 // Number of retries for chapter generation

	for i := state.FirstNewChapter - 1; i < totalChapters; i++ {
		chapterNum := i + 1

		log.Printf("Generating Chapter %d (out of %d)", chapterNum, totalChapters)

		prompt := fmt.Sprintf(`Given the following complete story abstract (plan) and the chapters already written, please write Chapter %d of the story.
Generate a short title for the charpter.
The chapter should be approximately %d words. Focus on progressing the narrative as outlined in the abstract for this specific chapter.

--- Full Story Abstract (Plan) ---
%s
--- End Full Story Abstract (Plan) ---

--- Previously Written Chapters (including abstract and previous chapters) ---
%s
--- End Previously Written Chapters ---

Write Chapter %d now, ensuring it flows logically from previous chapters and adheres to the overall story plan.
`,
			chapterNum,
			cfg.WordsPerChapter,
			cfg.AbstractContent,
			state.PreviousChapters,
			chapterNum,
		)

		var chapterText string
		var chapterSignature []byte
		var chapterInputTokens, chapterOutputTokens int
		var chapterCost float64
		var chapterGenerationErr error

		// Retry logic for CallGeminiAPI for chapter generation
		for attempt := 0; attempt <= maxChapterRetries; attempt++ {
			if attempt > 0 {
				log.Printf("Retrying Chapter %d (attempt %d/%d) after previous failure: %v", chapterNum, attempt, maxChapterRetries, chapterGenerationErr)
				time.Sleep(2 * time.Second) // Small delay before retrying
			}

			apiInput := aiEndpoint.CallGeminiAPIInput{
				Ctx:           context.Background(),
				APIKey:        cfg.APIKey,
				ModelName:     cfg.ModelName,
				Prompt:        prompt,
				ThinkingLevel: cfg.ThinkingLevel,
				// PreviousTurn: nil, // Not using conversation history struct, using prompt context + thought signature
				ThoughtSignature: state.LastThoughtSignature,
			}
			apiResponse := aiEndpoint.CallGeminiAPI(apiInput)

			chapterText = apiResponse.GeneratedText
			chapterSignature = apiResponse.ThoughtSignature
			chapterInputTokens = apiResponse.InputTokens
			chapterOutputTokens = apiResponse.OutputTokens
			chapterCost = apiResponse.Cost
			chapterGenerationErr = apiResponse.Err

			if chapterGenerationErr == nil {
				// Success, break out of retry loop
				break
			}
		}

		if chapterGenerationErr != nil {
			log.Fatalf("Critical Error: Failed to generate Chapter %d after %d attempts: %v. Marking chapter with error message and proceeding.", chapterNum, maxChapterRetries+1, chapterGenerationErr)
			// If all retries fail, mark the chapter with an error message in the output.
			chapterText = fmt.Sprintf("Error generating Chapter %d: %v\n\n[Generation Failed - Please review logs]", chapterNum, chapterGenerationErr)
			chapterSignature = nil // Clear signature if generation failed
			chapterInputTokens = 0
			chapterOutputTokens = 0
			chapterCost = 0
		}

		chapterContentToWrite := strings.TrimSpace(chapterText) + "\n\n"
		wordCount := len(strings.Fields(strings.ReplaceAll(chapterContentToWrite, "\n", " ")))
		chapterHeader := fmt.Sprintf("## Chapter %d\n\n", chapterNum)

		// Update State
		state.AccumulatedInputTokens += chapterInputTokens
		state.AccumulatedOutputTokens += chapterOutputTokens
		state.AccumulatedCost += chapterCost
		state.PreviousChapters += chapterHeader + chapterContentToWrite
		state.LastThoughtSignature = chapterSignature
		state.ChaptersAlreadyWritten = chapterNum

		log.Printf("Chapter %d tokens: English words %d, Input %d, Output %d, Cost: $%.6f. Accumulated tokens: Input %d, Output %d, Accumulated Cost: $%.6f",
			chapterNum, wordCount, chapterInputTokens, chapterOutputTokens, chapterCost, state.AccumulatedInputTokens, state.AccumulatedOutputTokens, state.AccumulatedCost)

		// Save Status and Rewrite Full Text File
		if err := saveStateToFiles(state, statusFilePath, outputFilePath); err != nil {
			return err
		}
		log.Printf("Chapter %d generated, status saved, and story file updated.", chapterNum)

		// Add a small delay to avoid hitting rate limits if generating many chapters quickly
		time.Sleep(1 * time.Second)
	}
	return nil
}

// Execute is the main entry point for the 'story' subcommand.
func Execute(args []string) error {
	// 1. Parse and validate flags
	cfg, err := parseAndValidateFlags(args)
	if err != nil {
		return err
	}

	// Preserve original log output and flags to restore later
	originalLogOutput := log.Writer()
	originalLogFlags := log.Flags()
	defer func() {
		log.SetOutput(originalLogOutput) // Restore original log output when Execute exits
		log.SetFlags(originalLogFlags)   // Restore original log flags
	}()

	// 2. Configure logging
	logFile, err := setupLogging(cfg.AbstractFilePath)
	if err != nil {
		// setupLogging already logs a warning and ensures logging goes to stderr.
	}
	if logFile != nil {
		defer logFile.Close() // Ensure the log file is closed
	}

	// 3. Load Gemini configuration
	cfg.APIKey, cfg.ModelName, cfg.ThinkingLevel, err = loadGeminiAPIConfig(cfg.ConfigPath)
	if err != nil {
		return err
	}

	// 4. Read abstract and determine total chapters
	var totalChapters int
	var initialInputTokens, initialOutputTokens int
	var initialCost float64
	cfg.AbstractContent, totalChapters, initialInputTokens, initialOutputTokens, initialCost, err = readAbstractAndDetermineTotalChapters(cfg)
	if err != nil {
		return err
	}

	// 5. Determine output paths
	finalOutputPath := determineOutputFilePath(cfg.AbstractFilePath, cfg.OutputPath)
	statusOutputPath := determineStatusFilePath(finalOutputPath)

	// 6. Initialize story state (resume logic based on status file)
	state, err := initializeStoryState(statusOutputPath, cfg.AbstractContent)
	if err != nil {
		return err
	}

	// Add initial token counts from chapter planning (only if starting fresh or if not already accounted for)
	// Since we are resuming from status, if status exists, these counts might already be in there if we were careful.
	// However, simple approach: add current run's setup cost to accumulator.
	state.AccumulatedInputTokens += initialInputTokens
	state.AccumulatedOutputTokens += initialOutputTokens
	state.AccumulatedCost += initialCost

	// 7. If starting fresh (no chapters written), save initial state and file content immediately
	if state.ChaptersAlreadyWritten == 0 {
		if err := saveStateToFiles(&state, statusOutputPath, finalOutputPath); err != nil {
			return fmt.Errorf("failed to save initial story state: %w", err)
		}
	}

	// 8. Generate story chapter by chapter
	if err := generateStoryChapters(cfg, totalChapters, &state, statusOutputPath, finalOutputPath); err != nil {
		return err
	}

	fmt.Printf("Full story successfully generated and saved to: %s\n", finalOutputPath)
	log.Printf("Full story saved to: %s. Total accumulated tokens: Input %d, Output %d. Total accumulated cost: $%.6f", finalOutputPath, state.AccumulatedInputTokens, state.AccumulatedOutputTokens, state.AccumulatedCost)
	fmt.Printf("Total accumulated cost for full story generation process: $%.6f\n", state.AccumulatedCost)

	return nil
}
